<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.9.2" />
<title>sedna.common.file_ops API documentation</title>
<meta name="description" content="FileOps class." />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>sedna.common.file_ops</code></h1>
</header>
<section id="section-intro">
<p>FileOps class.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2021 The KubeEdge Authors.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

&#34;&#34;&#34;FileOps class.&#34;&#34;&#34;

import os
import re

import joblib
import codecs
import pickle
import shutil
import hashlib
import tempfile
from urllib.parse import urlparse

from .utils import singleton


@singleton
def _create_minio_client():
    import minio

    _url = os.getenv(&#34;S3_ENDPOINT_URL&#34;, &#34;http://s3.amazonaws.com&#34;)
    if not (_url.startswith(&#34;http://&#34;) or _url.startswith(&#34;https://&#34;)):
        _url = f&#34;https://{_url}&#34;
    url = urlparse(_url)
    use_ssl = url.scheme == &#39;https&#39; if url.scheme else True

    s3 = minio.Minio(
        url.netloc,
        access_key=os.getenv(&#34;ACCESS_KEY_ID&#34;, &#34;&#34;),
        secret_key=os.getenv(&#34;SECRET_ACCESS_KEY&#34;, &#34;&#34;),
        secure=use_ssl
    )
    return s3


class FileOps:
    &#34;&#34;&#34;This is a class with some class methods
    to handle some files or folder.&#34;&#34;&#34;
    _GCS_PREFIX = &#34;gs://&#34;
    _S3_PREFIX = &#34;s3://&#34;
    _LOCAL_PREFIX = &#34;file://&#34;
    _URI_RE = &#34;https?://(.+)/(.+)&#34;
    _HTTP_PREFIX = &#34;http(s)://&#34;
    _HEADERS_SUFFIX = &#34;-headers&#34;

    @classmethod
    def make_dir(cls, *args):
        &#34;&#34;&#34;Make new a local directory.

        :param * args: list of str path to joined as a new directory to make.

        &#34;&#34;&#34;
        _path = cls.join_path(*args)
        if not os.path.isdir(_path):
            os.makedirs(_path, exist_ok=True)

    @classmethod
    def get_file_hash(cls, filepath):
        md5_hash = hashlib.md5()
        if not (filepath and os.path.isfile(filepath)):
            return &#34;&#34;
        a_file = open(filepath, &#34;rb&#34;)
        content = a_file.read()
        md5_hash.update(content)
        digest = md5_hash.hexdigest()
        return digest

    @classmethod
    def clean_folder(cls, target, clean=True):
        &#34;&#34;&#34;clean the target directories.
        create path if `target` not exists,
        initial path if `clean` be True

        :param target: list of str path need to clean.
        :type target: list
        :param clean: clear target if exists.
        :type clean: bool
        &#34;&#34;&#34;
        if isinstance(target, str):
            target = [target]
        for path in set(target):
            args = str(path).split(os.path.sep)
            if len(args) &lt; 2:
                continue
            if not args[0]:
                args[0] = os.path.sep
            _path = cls.join_path(*args)
            if clean:
                cls.delete(_path)
            if os.path.isfile(_path):
                _path = cls.join_path(*args[:len(args) - 1])
            os.makedirs(_path, exist_ok=True)
        return target

    @classmethod
    def delete(cls, path):
        try:
            if os.path.isdir(path):
                shutil.rmtree(path)
            if os.path.isfile(path):
                os.remove(path)
        except Exception:
            pass

    @classmethod
    def make_base_dir(cls, *args):
        &#34;&#34;&#34;Make new a base directory.

        :param * args: list of str path to joined as a
        new base directory to make.

        &#34;&#34;&#34;
        _file = cls.join_path(*args)
        if os.path.isfile(_file):
            return
        _path, _ = os.path.split(_file)
        if not os.path.isdir(_path):
            os.makedirs(_path, exist_ok=True)

    @classmethod
    def join_path(cls, *args):
        &#34;&#34;&#34;Join list of path and return.

        :param * args: list of str path to be joined.
        :return: joined path str.
        :rtype: str

        &#34;&#34;&#34;
        if len(args) == 1:
            return args[0]
        is_root = os.path.sep if str(args[0]).startswith(os.path.sep) else &#34;&#34;
        args = list(map(lambda x: x.lstrip(os.path.sep), args))
        args[0] = f&#34;{is_root}{args[0]}&#34;
        # local path
        if &#34;:&#34; not in args[0]:
            args = tuple(args)
            return os.path.join(*args)
        # http or s3 path
        tail = os.path.join(*args[1:])
        return os.path.join(args[0], tail)

    @classmethod
    def remove_path_prefix(cls, org_str: str, prefix: str):
        &#34;&#34;&#34;remove the prefix, for converting path
        in container to path in host.&#34;&#34;&#34;
        if not prefix:
            return org_str
        p = prefix[:-1] if prefix.endswith(os.path.sep) else prefix
        if org_str.startswith(p):
            out_str = org_str.replace(p, &#39;&#39;, 1)
            return out_str
        else:
            return org_str

    @classmethod
    def dump_pickle(cls, obj, filename):
        &#34;&#34;&#34;Dump a object to a file using pickle.

        :param object obj: target object.
        :param str filename: target pickle file path.

        &#34;&#34;&#34;
        if not os.path.isfile(filename):
            cls.make_base_dir(filename)
        with open(filename, &#34;wb&#34;) as f:
            pickle.dump(obj, f)

    @classmethod
    def load_pickle(cls, filename):
        &#34;&#34;&#34;Load a pickle file and return the object.

        :param str filename: target pickle file path.
        :return: return the loaded original object.
        :rtype: object or None.

        &#34;&#34;&#34;
        if not os.path.isfile(filename):
            return None
        with open(filename, &#34;rb&#34;) as f:
            return pickle.load(f)

    @classmethod
    def copy_folder(cls, src, dst):
        &#34;&#34;&#34;Copy a folder from source to destination.

        :param str src: source path.
        :param str dst: destination path.

        &#34;&#34;&#34;
        if dst is None or dst == &#34;&#34; or (not os.path.isdir(src)):
            return
        if not os.path.exists(dst):
            shutil.copytree(src, dst)
        else:
            if os.path.samefile(src, dst):
                return
            for files in os.listdir(src):
                name = os.path.join(src, files)
                back_name = os.path.join(dst, files)
                if os.path.isfile(name):
                    if os.path.isfile(back_name):
                        shutil.copy(name, back_name)
                else:
                    if not os.path.isdir(back_name):
                        shutil.copytree(name, back_name)
                    else:
                        cls.copy_folder(name, back_name)

    @classmethod
    def copy_file(cls, src, dst):
        &#34;&#34;&#34;Copy a file from source to destination.

        :param str src: source path.
        :param str dst: destination path.

        &#34;&#34;&#34;
        if not dst:
            return

        if os.path.isfile(src):
            if os.path.isfile(dst) and os.path.samefile(src, dst):
                return
            if os.path.isdir(dst):
                basename = os.path.basename(src)
                dst = os.path.join(dst, basename)
            parent_dir = os.path.dirname(dst)
            cls.clean_folder([parent_dir], clean=False)

            shutil.copy(src, dst)
        elif os.path.isdir(src):
            cls.clean_folder([dst], clean=False)
            cls.copy_folder(src, dst)

    @classmethod
    def dump(cls, obj, dst=None) -&gt; str:
        fd, name = tempfile.mkstemp()
        os.close(fd)
        joblib.dump(obj, name)
        return FileOps.upload(name, dst)

    @classmethod
    def is_remote(cls, src):
        if src.startswith((
                cls._GCS_PREFIX,
                cls._S3_PREFIX
        )):
            return True
        if re.search(cls._URI_RE, src):
            return True
        return False

    @classmethod
    def download(cls, src, dst=None, unzip=False) -&gt; str:
        if dst is None:
            fd, dst = tempfile.mkstemp()
            os.close(fd)
        cls.clean_folder([os.path.dirname(dst)], clean=False)
        if src.startswith(cls._GCS_PREFIX):
            cls.gcs_download(src, dst)
        elif src.startswith(cls._S3_PREFIX):
            cls.s3_download(src, dst)
        elif cls.is_local(src):
            cls.copy_file(src, dst)
        elif re.search(cls._URI_RE, src):
            cls.http_download(src, dst)
        if unzip is True and dst.endswith(&#34;.tar.gz&#34;):
            cls._untar(dst)
        return dst

    @classmethod
    def upload(cls, src, dst, tar=False, clean=True) -&gt; str:
        if dst is None:
            fd, dst = tempfile.mkstemp()
            os.close(fd)
        if not cls.is_local(src):
            fd, name = tempfile.mkstemp()
            os.close(fd)
            cls.download(src, name)
            src = name
        if tar:
            cls._tar(src, f&#34;{src}.tar.gz&#34;)
            src = f&#34;{src}.tar.gz&#34;

        if dst.startswith(cls._GCS_PREFIX):
            cls.gcs_upload(src, dst)
        elif dst.startswith(cls._S3_PREFIX):
            cls.s3_upload(src, dst)
        else:
            cls.copy_file(src, dst)
        if cls.is_local(src) and clean:
            if cls.is_local(dst) and os.path.samefile(src, dst):
                return dst
            cls.delete(src)
        return dst

    @classmethod
    def is_local(cls, src):
        return src.startswith(cls._LOCAL_PREFIX) or cls.exists(src)

    @classmethod
    def gcs_download(cls, src, dst):
        &#34;&#34;&#34;todo: not support now&#34;&#34;&#34;

    @classmethod
    def gcs_upload(cls, src, dst):
        &#34;&#34;&#34;todo: not support now&#34;&#34;&#34;

    @classmethod
    def _download_s3(cls, client, uri, out_dir):
        bucket_args = uri.replace(cls._S3_PREFIX, &#34;&#34;, 1).split(&#34;/&#34;, 1)
        bucket_name = bucket_args[0]
        bucket_path = len(bucket_args) &gt; 1 and bucket_args[1] or &#34;&#34;

        objects = list(client.list_objects(bucket_name,
                                           prefix=bucket_path,
                                           recursive=True,
                                           use_api_v1=True))
        count = 0
        num = len(objects)
        for obj in objects:
            # Replace any prefix from the object key with out_dir
            subdir_object_key = obj.object_name[len(bucket_path):].strip(&#34;/&#34;)
            # fget_object handles directory creation if does not exist
            if not obj.is_dir:
                if num == 1 and not os.path.isdir(out_dir):
                    local_file = out_dir
                else:
                    local_file = os.path.join(
                        out_dir,
                        subdir_object_key or os.path.basename(obj.object_name)
                    )
                client.fget_object(bucket_name, obj.object_name, local_file)
                count += 1

        return count

    @classmethod
    def s3_download(cls, src, dst):
        s3 = _create_minio_client()
        count = cls._download_s3(s3, src, dst)

        if count == 0:
            raise RuntimeError(&#34;Failed to fetch files.&#34;
                               &#34;The path %s does not exist.&#34; % src)

    @classmethod
    def s3_upload(cls, src, dst):

        s3 = _create_minio_client()
        parsed = urlparse(dst, scheme=&#39;s3&#39;)
        bucket_name = parsed.netloc

        def _s3_upload(_file, fname=&#34;&#34;):
            _file_handle = open(_file, &#39;rb&#39;)
            _file_handle.seek(0, os.SEEK_END)
            size = _file_handle.tell()
            _file_handle.seek(0)
            if not fname:
                fname = os.path.basename(fname)
            s3.put_object(bucket_name, fname, _file_handle, size)
            _file_handle.close()
            return size

        if os.path.isdir(src):
            for root, _, files in os.walk(src):
                for file in files:
                    filepath = os.path.join(root, file)
                    name = os.path.relpath(filepath, src)
                    _s3_upload(filepath, name)
        elif os.path.isfile(src):
            _s3_upload(src, parsed.path.lstrip(&#34;/&#34;))

    @classmethod
    def http_download(cls, src, dst):
        &#34;&#34;&#34;Download data from http or https web site.

        :param src: the data path
        :type src: str
        :param dst: the data path
        :type dst: str
        :raises FileNotFoundError: if the file path is
         not exist, an error will raise
        &#34;&#34;&#34;
        from six.moves import urllib

        try:
            urllib.request.urlretrieve(src, dst)
        except (urllib.error.URLError, IOError) as e:
            raise e

    @classmethod
    def _untar(cls, src, dst=None):
        import tarfile
        if dst is None:
            dst = os.path.dirname(src)
        with tarfile.open(src, &#39;r:gz&#39;) as tar:
            tar.extractall(path=dst)

    @classmethod
    def _tar(cls, src, dst):
        import tarfile
        with tarfile.open(dst, &#39;w:gz&#39;) as tar:
            if os.path.isdir(src):
                for root, _, files in os.walk(src):
                    for file in files:
                        filepath = os.path.join(root, file)
                        tar.add(filepath)
            elif os.path.isfile(src):
                tar.add(os.path.realpath(src))

    @classmethod
    def exists(cls, folder):
        &#34;&#34;&#34;Is folder existed or not.

        :param folder: folder
        :type folder: str
        :return: folder existed or not.
        :rtype: bool
        &#34;&#34;&#34;
        return os.path.isdir(folder) or os.path.isfile(folder)

    @classmethod
    def obj_to_pickle_string(cls, x):
        return codecs.encode(pickle.dumps(x), &#34;base64&#34;).decode()

    @classmethod
    def pickle_string_to_obj(cls, s):
        return pickle.loads(codecs.decode(s.encode(), &#34;base64&#34;))</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="sedna.common.file_ops.FileOps"><code class="flex name class">
<span>class <span class="ident">FileOps</span></span>
</code></dt>
<dd>
<div class="desc"><p>This is a class with some class methods
to handle some files or folder.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class FileOps:
    &#34;&#34;&#34;This is a class with some class methods
    to handle some files or folder.&#34;&#34;&#34;
    _GCS_PREFIX = &#34;gs://&#34;
    _S3_PREFIX = &#34;s3://&#34;
    _LOCAL_PREFIX = &#34;file://&#34;
    _URI_RE = &#34;https?://(.+)/(.+)&#34;
    _HTTP_PREFIX = &#34;http(s)://&#34;
    _HEADERS_SUFFIX = &#34;-headers&#34;

    @classmethod
    def make_dir(cls, *args):
        &#34;&#34;&#34;Make new a local directory.

        :param * args: list of str path to joined as a new directory to make.

        &#34;&#34;&#34;
        _path = cls.join_path(*args)
        if not os.path.isdir(_path):
            os.makedirs(_path, exist_ok=True)

    @classmethod
    def get_file_hash(cls, filepath):
        md5_hash = hashlib.md5()
        if not (filepath and os.path.isfile(filepath)):
            return &#34;&#34;
        a_file = open(filepath, &#34;rb&#34;)
        content = a_file.read()
        md5_hash.update(content)
        digest = md5_hash.hexdigest()
        return digest

    @classmethod
    def clean_folder(cls, target, clean=True):
        &#34;&#34;&#34;clean the target directories.
        create path if `target` not exists,
        initial path if `clean` be True

        :param target: list of str path need to clean.
        :type target: list
        :param clean: clear target if exists.
        :type clean: bool
        &#34;&#34;&#34;
        if isinstance(target, str):
            target = [target]
        for path in set(target):
            args = str(path).split(os.path.sep)
            if len(args) &lt; 2:
                continue
            if not args[0]:
                args[0] = os.path.sep
            _path = cls.join_path(*args)
            if clean:
                cls.delete(_path)
            if os.path.isfile(_path):
                _path = cls.join_path(*args[:len(args) - 1])
            os.makedirs(_path, exist_ok=True)
        return target

    @classmethod
    def delete(cls, path):
        try:
            if os.path.isdir(path):
                shutil.rmtree(path)
            if os.path.isfile(path):
                os.remove(path)
        except Exception:
            pass

    @classmethod
    def make_base_dir(cls, *args):
        &#34;&#34;&#34;Make new a base directory.

        :param * args: list of str path to joined as a
        new base directory to make.

        &#34;&#34;&#34;
        _file = cls.join_path(*args)
        if os.path.isfile(_file):
            return
        _path, _ = os.path.split(_file)
        if not os.path.isdir(_path):
            os.makedirs(_path, exist_ok=True)

    @classmethod
    def join_path(cls, *args):
        &#34;&#34;&#34;Join list of path and return.

        :param * args: list of str path to be joined.
        :return: joined path str.
        :rtype: str

        &#34;&#34;&#34;
        if len(args) == 1:
            return args[0]
        is_root = os.path.sep if str(args[0]).startswith(os.path.sep) else &#34;&#34;
        args = list(map(lambda x: x.lstrip(os.path.sep), args))
        args[0] = f&#34;{is_root}{args[0]}&#34;
        # local path
        if &#34;:&#34; not in args[0]:
            args = tuple(args)
            return os.path.join(*args)
        # http or s3 path
        tail = os.path.join(*args[1:])
        return os.path.join(args[0], tail)

    @classmethod
    def remove_path_prefix(cls, org_str: str, prefix: str):
        &#34;&#34;&#34;remove the prefix, for converting path
        in container to path in host.&#34;&#34;&#34;
        if not prefix:
            return org_str
        p = prefix[:-1] if prefix.endswith(os.path.sep) else prefix
        if org_str.startswith(p):
            out_str = org_str.replace(p, &#39;&#39;, 1)
            return out_str
        else:
            return org_str

    @classmethod
    def dump_pickle(cls, obj, filename):
        &#34;&#34;&#34;Dump a object to a file using pickle.

        :param object obj: target object.
        :param str filename: target pickle file path.

        &#34;&#34;&#34;
        if not os.path.isfile(filename):
            cls.make_base_dir(filename)
        with open(filename, &#34;wb&#34;) as f:
            pickle.dump(obj, f)

    @classmethod
    def load_pickle(cls, filename):
        &#34;&#34;&#34;Load a pickle file and return the object.

        :param str filename: target pickle file path.
        :return: return the loaded original object.
        :rtype: object or None.

        &#34;&#34;&#34;
        if not os.path.isfile(filename):
            return None
        with open(filename, &#34;rb&#34;) as f:
            return pickle.load(f)

    @classmethod
    def copy_folder(cls, src, dst):
        &#34;&#34;&#34;Copy a folder from source to destination.

        :param str src: source path.
        :param str dst: destination path.

        &#34;&#34;&#34;
        if dst is None or dst == &#34;&#34; or (not os.path.isdir(src)):
            return
        if not os.path.exists(dst):
            shutil.copytree(src, dst)
        else:
            if os.path.samefile(src, dst):
                return
            for files in os.listdir(src):
                name = os.path.join(src, files)
                back_name = os.path.join(dst, files)
                if os.path.isfile(name):
                    if os.path.isfile(back_name):
                        shutil.copy(name, back_name)
                else:
                    if not os.path.isdir(back_name):
                        shutil.copytree(name, back_name)
                    else:
                        cls.copy_folder(name, back_name)

    @classmethod
    def copy_file(cls, src, dst):
        &#34;&#34;&#34;Copy a file from source to destination.

        :param str src: source path.
        :param str dst: destination path.

        &#34;&#34;&#34;
        if not dst:
            return

        if os.path.isfile(src):
            if os.path.isfile(dst) and os.path.samefile(src, dst):
                return
            if os.path.isdir(dst):
                basename = os.path.basename(src)
                dst = os.path.join(dst, basename)
            parent_dir = os.path.dirname(dst)
            cls.clean_folder([parent_dir], clean=False)

            shutil.copy(src, dst)
        elif os.path.isdir(src):
            cls.clean_folder([dst], clean=False)
            cls.copy_folder(src, dst)

    @classmethod
    def dump(cls, obj, dst=None) -&gt; str:
        fd, name = tempfile.mkstemp()
        os.close(fd)
        joblib.dump(obj, name)
        return FileOps.upload(name, dst)

    @classmethod
    def is_remote(cls, src):
        if src.startswith((
                cls._GCS_PREFIX,
                cls._S3_PREFIX
        )):
            return True
        if re.search(cls._URI_RE, src):
            return True
        return False

    @classmethod
    def download(cls, src, dst=None, unzip=False) -&gt; str:
        if dst is None:
            fd, dst = tempfile.mkstemp()
            os.close(fd)
        cls.clean_folder([os.path.dirname(dst)], clean=False)
        if src.startswith(cls._GCS_PREFIX):
            cls.gcs_download(src, dst)
        elif src.startswith(cls._S3_PREFIX):
            cls.s3_download(src, dst)
        elif cls.is_local(src):
            cls.copy_file(src, dst)
        elif re.search(cls._URI_RE, src):
            cls.http_download(src, dst)
        if unzip is True and dst.endswith(&#34;.tar.gz&#34;):
            cls._untar(dst)
        return dst

    @classmethod
    def upload(cls, src, dst, tar=False, clean=True) -&gt; str:
        if dst is None:
            fd, dst = tempfile.mkstemp()
            os.close(fd)
        if not cls.is_local(src):
            fd, name = tempfile.mkstemp()
            os.close(fd)
            cls.download(src, name)
            src = name
        if tar:
            cls._tar(src, f&#34;{src}.tar.gz&#34;)
            src = f&#34;{src}.tar.gz&#34;

        if dst.startswith(cls._GCS_PREFIX):
            cls.gcs_upload(src, dst)
        elif dst.startswith(cls._S3_PREFIX):
            cls.s3_upload(src, dst)
        else:
            cls.copy_file(src, dst)
        if cls.is_local(src) and clean:
            if cls.is_local(dst) and os.path.samefile(src, dst):
                return dst
            cls.delete(src)
        return dst

    @classmethod
    def is_local(cls, src):
        return src.startswith(cls._LOCAL_PREFIX) or cls.exists(src)

    @classmethod
    def gcs_download(cls, src, dst):
        &#34;&#34;&#34;todo: not support now&#34;&#34;&#34;

    @classmethod
    def gcs_upload(cls, src, dst):
        &#34;&#34;&#34;todo: not support now&#34;&#34;&#34;

    @classmethod
    def _download_s3(cls, client, uri, out_dir):
        bucket_args = uri.replace(cls._S3_PREFIX, &#34;&#34;, 1).split(&#34;/&#34;, 1)
        bucket_name = bucket_args[0]
        bucket_path = len(bucket_args) &gt; 1 and bucket_args[1] or &#34;&#34;

        objects = list(client.list_objects(bucket_name,
                                           prefix=bucket_path,
                                           recursive=True,
                                           use_api_v1=True))
        count = 0
        num = len(objects)
        for obj in objects:
            # Replace any prefix from the object key with out_dir
            subdir_object_key = obj.object_name[len(bucket_path):].strip(&#34;/&#34;)
            # fget_object handles directory creation if does not exist
            if not obj.is_dir:
                if num == 1 and not os.path.isdir(out_dir):
                    local_file = out_dir
                else:
                    local_file = os.path.join(
                        out_dir,
                        subdir_object_key or os.path.basename(obj.object_name)
                    )
                client.fget_object(bucket_name, obj.object_name, local_file)
                count += 1

        return count

    @classmethod
    def s3_download(cls, src, dst):
        s3 = _create_minio_client()
        count = cls._download_s3(s3, src, dst)

        if count == 0:
            raise RuntimeError(&#34;Failed to fetch files.&#34;
                               &#34;The path %s does not exist.&#34; % src)

    @classmethod
    def s3_upload(cls, src, dst):

        s3 = _create_minio_client()
        parsed = urlparse(dst, scheme=&#39;s3&#39;)
        bucket_name = parsed.netloc

        def _s3_upload(_file, fname=&#34;&#34;):
            _file_handle = open(_file, &#39;rb&#39;)
            _file_handle.seek(0, os.SEEK_END)
            size = _file_handle.tell()
            _file_handle.seek(0)
            if not fname:
                fname = os.path.basename(fname)
            s3.put_object(bucket_name, fname, _file_handle, size)
            _file_handle.close()
            return size

        if os.path.isdir(src):
            for root, _, files in os.walk(src):
                for file in files:
                    filepath = os.path.join(root, file)
                    name = os.path.relpath(filepath, src)
                    _s3_upload(filepath, name)
        elif os.path.isfile(src):
            _s3_upload(src, parsed.path.lstrip(&#34;/&#34;))

    @classmethod
    def http_download(cls, src, dst):
        &#34;&#34;&#34;Download data from http or https web site.

        :param src: the data path
        :type src: str
        :param dst: the data path
        :type dst: str
        :raises FileNotFoundError: if the file path is
         not exist, an error will raise
        &#34;&#34;&#34;
        from six.moves import urllib

        try:
            urllib.request.urlretrieve(src, dst)
        except (urllib.error.URLError, IOError) as e:
            raise e

    @classmethod
    def _untar(cls, src, dst=None):
        import tarfile
        if dst is None:
            dst = os.path.dirname(src)
        with tarfile.open(src, &#39;r:gz&#39;) as tar:
            tar.extractall(path=dst)

    @classmethod
    def _tar(cls, src, dst):
        import tarfile
        with tarfile.open(dst, &#39;w:gz&#39;) as tar:
            if os.path.isdir(src):
                for root, _, files in os.walk(src):
                    for file in files:
                        filepath = os.path.join(root, file)
                        tar.add(filepath)
            elif os.path.isfile(src):
                tar.add(os.path.realpath(src))

    @classmethod
    def exists(cls, folder):
        &#34;&#34;&#34;Is folder existed or not.

        :param folder: folder
        :type folder: str
        :return: folder existed or not.
        :rtype: bool
        &#34;&#34;&#34;
        return os.path.isdir(folder) or os.path.isfile(folder)

    @classmethod
    def obj_to_pickle_string(cls, x):
        return codecs.encode(pickle.dumps(x), &#34;base64&#34;).decode()

    @classmethod
    def pickle_string_to_obj(cls, s):
        return pickle.loads(codecs.decode(s.encode(), &#34;base64&#34;))</code></pre>
</details>
<h3>Static methods</h3>
<dl>
<dt id="sedna.common.file_ops.FileOps.clean_folder"><code class="name flex">
<span>def <span class="ident">clean_folder</span></span>(<span>target, clean=True)</span>
</code></dt>
<dd>
<div class="desc"><p>clean the target directories.
create path if <code>target</code> not exists,
initial path if <code>clean</code> be True</p>
<p>:param target: list of str path need to clean.
:type target: list
:param clean: clear target if exists.
:type clean: bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def clean_folder(cls, target, clean=True):
    &#34;&#34;&#34;clean the target directories.
    create path if `target` not exists,
    initial path if `clean` be True

    :param target: list of str path need to clean.
    :type target: list
    :param clean: clear target if exists.
    :type clean: bool
    &#34;&#34;&#34;
    if isinstance(target, str):
        target = [target]
    for path in set(target):
        args = str(path).split(os.path.sep)
        if len(args) &lt; 2:
            continue
        if not args[0]:
            args[0] = os.path.sep
        _path = cls.join_path(*args)
        if clean:
            cls.delete(_path)
        if os.path.isfile(_path):
            _path = cls.join_path(*args[:len(args) - 1])
        os.makedirs(_path, exist_ok=True)
    return target</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.copy_file"><code class="name flex">
<span>def <span class="ident">copy_file</span></span>(<span>src, dst)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy a file from source to destination.</p>
<p>:param str src: source path.
:param str dst: destination path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def copy_file(cls, src, dst):
    &#34;&#34;&#34;Copy a file from source to destination.

    :param str src: source path.
    :param str dst: destination path.

    &#34;&#34;&#34;
    if not dst:
        return

    if os.path.isfile(src):
        if os.path.isfile(dst) and os.path.samefile(src, dst):
            return
        if os.path.isdir(dst):
            basename = os.path.basename(src)
            dst = os.path.join(dst, basename)
        parent_dir = os.path.dirname(dst)
        cls.clean_folder([parent_dir], clean=False)

        shutil.copy(src, dst)
    elif os.path.isdir(src):
        cls.clean_folder([dst], clean=False)
        cls.copy_folder(src, dst)</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.copy_folder"><code class="name flex">
<span>def <span class="ident">copy_folder</span></span>(<span>src, dst)</span>
</code></dt>
<dd>
<div class="desc"><p>Copy a folder from source to destination.</p>
<p>:param str src: source path.
:param str dst: destination path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def copy_folder(cls, src, dst):
    &#34;&#34;&#34;Copy a folder from source to destination.

    :param str src: source path.
    :param str dst: destination path.

    &#34;&#34;&#34;
    if dst is None or dst == &#34;&#34; or (not os.path.isdir(src)):
        return
    if not os.path.exists(dst):
        shutil.copytree(src, dst)
    else:
        if os.path.samefile(src, dst):
            return
        for files in os.listdir(src):
            name = os.path.join(src, files)
            back_name = os.path.join(dst, files)
            if os.path.isfile(name):
                if os.path.isfile(back_name):
                    shutil.copy(name, back_name)
            else:
                if not os.path.isdir(back_name):
                    shutil.copytree(name, back_name)
                else:
                    cls.copy_folder(name, back_name)</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.delete"><code class="name flex">
<span>def <span class="ident">delete</span></span>(<span>path)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def delete(cls, path):
    try:
        if os.path.isdir(path):
            shutil.rmtree(path)
        if os.path.isfile(path):
            os.remove(path)
    except Exception:
        pass</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.download"><code class="name flex">
<span>def <span class="ident">download</span></span>(<span>src, dst=None, unzip=False) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def download(cls, src, dst=None, unzip=False) -&gt; str:
    if dst is None:
        fd, dst = tempfile.mkstemp()
        os.close(fd)
    cls.clean_folder([os.path.dirname(dst)], clean=False)
    if src.startswith(cls._GCS_PREFIX):
        cls.gcs_download(src, dst)
    elif src.startswith(cls._S3_PREFIX):
        cls.s3_download(src, dst)
    elif cls.is_local(src):
        cls.copy_file(src, dst)
    elif re.search(cls._URI_RE, src):
        cls.http_download(src, dst)
    if unzip is True and dst.endswith(&#34;.tar.gz&#34;):
        cls._untar(dst)
    return dst</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.dump"><code class="name flex">
<span>def <span class="ident">dump</span></span>(<span>obj, dst=None) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def dump(cls, obj, dst=None) -&gt; str:
    fd, name = tempfile.mkstemp()
    os.close(fd)
    joblib.dump(obj, name)
    return FileOps.upload(name, dst)</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.dump_pickle"><code class="name flex">
<span>def <span class="ident">dump_pickle</span></span>(<span>obj, filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Dump a object to a file using pickle.</p>
<p>:param object obj: target object.
:param str filename: target pickle file path.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def dump_pickle(cls, obj, filename):
    &#34;&#34;&#34;Dump a object to a file using pickle.

    :param object obj: target object.
    :param str filename: target pickle file path.

    &#34;&#34;&#34;
    if not os.path.isfile(filename):
        cls.make_base_dir(filename)
    with open(filename, &#34;wb&#34;) as f:
        pickle.dump(obj, f)</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.exists"><code class="name flex">
<span>def <span class="ident">exists</span></span>(<span>folder)</span>
</code></dt>
<dd>
<div class="desc"><p>Is folder existed or not.</p>
<p>:param folder: folder
:type folder: str
:return: folder existed or not.
:rtype: bool</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def exists(cls, folder):
    &#34;&#34;&#34;Is folder existed or not.

    :param folder: folder
    :type folder: str
    :return: folder existed or not.
    :rtype: bool
    &#34;&#34;&#34;
    return os.path.isdir(folder) or os.path.isfile(folder)</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.gcs_download"><code class="name flex">
<span>def <span class="ident">gcs_download</span></span>(<span>src, dst)</span>
</code></dt>
<dd>
<div class="desc"><p>todo: not support now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def gcs_download(cls, src, dst):
    &#34;&#34;&#34;todo: not support now&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.gcs_upload"><code class="name flex">
<span>def <span class="ident">gcs_upload</span></span>(<span>src, dst)</span>
</code></dt>
<dd>
<div class="desc"><p>todo: not support now</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def gcs_upload(cls, src, dst):
    &#34;&#34;&#34;todo: not support now&#34;&#34;&#34;</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.get_file_hash"><code class="name flex">
<span>def <span class="ident">get_file_hash</span></span>(<span>filepath)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def get_file_hash(cls, filepath):
    md5_hash = hashlib.md5()
    if not (filepath and os.path.isfile(filepath)):
        return &#34;&#34;
    a_file = open(filepath, &#34;rb&#34;)
    content = a_file.read()
    md5_hash.update(content)
    digest = md5_hash.hexdigest()
    return digest</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.http_download"><code class="name flex">
<span>def <span class="ident">http_download</span></span>(<span>src, dst)</span>
</code></dt>
<dd>
<div class="desc"><p>Download data from http or https web site.</p>
<p>:param src: the data path
:type src: str
:param dst: the data path
:type dst: str
:raises FileNotFoundError: if the file path is
not exist, an error will raise</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def http_download(cls, src, dst):
    &#34;&#34;&#34;Download data from http or https web site.

    :param src: the data path
    :type src: str
    :param dst: the data path
    :type dst: str
    :raises FileNotFoundError: if the file path is
     not exist, an error will raise
    &#34;&#34;&#34;
    from six.moves import urllib

    try:
        urllib.request.urlretrieve(src, dst)
    except (urllib.error.URLError, IOError) as e:
        raise e</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.is_local"><code class="name flex">
<span>def <span class="ident">is_local</span></span>(<span>src)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_local(cls, src):
    return src.startswith(cls._LOCAL_PREFIX) or cls.exists(src)</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.is_remote"><code class="name flex">
<span>def <span class="ident">is_remote</span></span>(<span>src)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def is_remote(cls, src):
    if src.startswith((
            cls._GCS_PREFIX,
            cls._S3_PREFIX
    )):
        return True
    if re.search(cls._URI_RE, src):
        return True
    return False</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.join_path"><code class="name flex">
<span>def <span class="ident">join_path</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Join list of path and return.</p>
<p>:param * args: list of str path to be joined.
:return: joined path str.
:rtype: str</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def join_path(cls, *args):
    &#34;&#34;&#34;Join list of path and return.

    :param * args: list of str path to be joined.
    :return: joined path str.
    :rtype: str

    &#34;&#34;&#34;
    if len(args) == 1:
        return args[0]
    is_root = os.path.sep if str(args[0]).startswith(os.path.sep) else &#34;&#34;
    args = list(map(lambda x: x.lstrip(os.path.sep), args))
    args[0] = f&#34;{is_root}{args[0]}&#34;
    # local path
    if &#34;:&#34; not in args[0]:
        args = tuple(args)
        return os.path.join(*args)
    # http or s3 path
    tail = os.path.join(*args[1:])
    return os.path.join(args[0], tail)</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.load_pickle"><code class="name flex">
<span>def <span class="ident">load_pickle</span></span>(<span>filename)</span>
</code></dt>
<dd>
<div class="desc"><p>Load a pickle file and return the object.</p>
<p>:param str filename: target pickle file path.
:return: return the loaded original object.
:rtype: object or None.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def load_pickle(cls, filename):
    &#34;&#34;&#34;Load a pickle file and return the object.

    :param str filename: target pickle file path.
    :return: return the loaded original object.
    :rtype: object or None.

    &#34;&#34;&#34;
    if not os.path.isfile(filename):
        return None
    with open(filename, &#34;rb&#34;) as f:
        return pickle.load(f)</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.make_base_dir"><code class="name flex">
<span>def <span class="ident">make_base_dir</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Make new a base directory.</p>
<p>:param * args: list of str path to joined as a
new base directory to make.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def make_base_dir(cls, *args):
    &#34;&#34;&#34;Make new a base directory.

    :param * args: list of str path to joined as a
    new base directory to make.

    &#34;&#34;&#34;
    _file = cls.join_path(*args)
    if os.path.isfile(_file):
        return
    _path, _ = os.path.split(_file)
    if not os.path.isdir(_path):
        os.makedirs(_path, exist_ok=True)</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.make_dir"><code class="name flex">
<span>def <span class="ident">make_dir</span></span>(<span>*args)</span>
</code></dt>
<dd>
<div class="desc"><p>Make new a local directory.</p>
<p>:param * args: list of str path to joined as a new directory to make.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def make_dir(cls, *args):
    &#34;&#34;&#34;Make new a local directory.

    :param * args: list of str path to joined as a new directory to make.

    &#34;&#34;&#34;
    _path = cls.join_path(*args)
    if not os.path.isdir(_path):
        os.makedirs(_path, exist_ok=True)</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.obj_to_pickle_string"><code class="name flex">
<span>def <span class="ident">obj_to_pickle_string</span></span>(<span>x)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def obj_to_pickle_string(cls, x):
    return codecs.encode(pickle.dumps(x), &#34;base64&#34;).decode()</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.pickle_string_to_obj"><code class="name flex">
<span>def <span class="ident">pickle_string_to_obj</span></span>(<span>s)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def pickle_string_to_obj(cls, s):
    return pickle.loads(codecs.decode(s.encode(), &#34;base64&#34;))</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.remove_path_prefix"><code class="name flex">
<span>def <span class="ident">remove_path_prefix</span></span>(<span>org_str: str, prefix: str)</span>
</code></dt>
<dd>
<div class="desc"><p>remove the prefix, for converting path
in container to path in host.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def remove_path_prefix(cls, org_str: str, prefix: str):
    &#34;&#34;&#34;remove the prefix, for converting path
    in container to path in host.&#34;&#34;&#34;
    if not prefix:
        return org_str
    p = prefix[:-1] if prefix.endswith(os.path.sep) else prefix
    if org_str.startswith(p):
        out_str = org_str.replace(p, &#39;&#39;, 1)
        return out_str
    else:
        return org_str</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.s3_download"><code class="name flex">
<span>def <span class="ident">s3_download</span></span>(<span>src, dst)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def s3_download(cls, src, dst):
    s3 = _create_minio_client()
    count = cls._download_s3(s3, src, dst)

    if count == 0:
        raise RuntimeError(&#34;Failed to fetch files.&#34;
                           &#34;The path %s does not exist.&#34; % src)</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.s3_upload"><code class="name flex">
<span>def <span class="ident">s3_upload</span></span>(<span>src, dst)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def s3_upload(cls, src, dst):

    s3 = _create_minio_client()
    parsed = urlparse(dst, scheme=&#39;s3&#39;)
    bucket_name = parsed.netloc

    def _s3_upload(_file, fname=&#34;&#34;):
        _file_handle = open(_file, &#39;rb&#39;)
        _file_handle.seek(0, os.SEEK_END)
        size = _file_handle.tell()
        _file_handle.seek(0)
        if not fname:
            fname = os.path.basename(fname)
        s3.put_object(bucket_name, fname, _file_handle, size)
        _file_handle.close()
        return size

    if os.path.isdir(src):
        for root, _, files in os.walk(src):
            for file in files:
                filepath = os.path.join(root, file)
                name = os.path.relpath(filepath, src)
                _s3_upload(filepath, name)
    elif os.path.isfile(src):
        _s3_upload(src, parsed.path.lstrip(&#34;/&#34;))</code></pre>
</details>
</dd>
<dt id="sedna.common.file_ops.FileOps.upload"><code class="name flex">
<span>def <span class="ident">upload</span></span>(<span>src, dst, tar=False, clean=True) ‑> str</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">@classmethod
def upload(cls, src, dst, tar=False, clean=True) -&gt; str:
    if dst is None:
        fd, dst = tempfile.mkstemp()
        os.close(fd)
    if not cls.is_local(src):
        fd, name = tempfile.mkstemp()
        os.close(fd)
        cls.download(src, name)
        src = name
    if tar:
        cls._tar(src, f&#34;{src}.tar.gz&#34;)
        src = f&#34;{src}.tar.gz&#34;

    if dst.startswith(cls._GCS_PREFIX):
        cls.gcs_upload(src, dst)
    elif dst.startswith(cls._S3_PREFIX):
        cls.s3_upload(src, dst)
    else:
        cls.copy_file(src, dst)
    if cls.is_local(src) and clean:
        if cls.is_local(dst) and os.path.samefile(src, dst):
            return dst
        cls.delete(src)
    return dst</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="sedna.common" href="index.html">sedna.common</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="sedna.common.file_ops.FileOps" href="#sedna.common.file_ops.FileOps">FileOps</a></code></h4>
<ul class="">
<li><code><a title="sedna.common.file_ops.FileOps.clean_folder" href="#sedna.common.file_ops.FileOps.clean_folder">clean_folder</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.copy_file" href="#sedna.common.file_ops.FileOps.copy_file">copy_file</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.copy_folder" href="#sedna.common.file_ops.FileOps.copy_folder">copy_folder</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.delete" href="#sedna.common.file_ops.FileOps.delete">delete</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.download" href="#sedna.common.file_ops.FileOps.download">download</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.dump" href="#sedna.common.file_ops.FileOps.dump">dump</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.dump_pickle" href="#sedna.common.file_ops.FileOps.dump_pickle">dump_pickle</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.exists" href="#sedna.common.file_ops.FileOps.exists">exists</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.gcs_download" href="#sedna.common.file_ops.FileOps.gcs_download">gcs_download</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.gcs_upload" href="#sedna.common.file_ops.FileOps.gcs_upload">gcs_upload</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.get_file_hash" href="#sedna.common.file_ops.FileOps.get_file_hash">get_file_hash</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.http_download" href="#sedna.common.file_ops.FileOps.http_download">http_download</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.is_local" href="#sedna.common.file_ops.FileOps.is_local">is_local</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.is_remote" href="#sedna.common.file_ops.FileOps.is_remote">is_remote</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.join_path" href="#sedna.common.file_ops.FileOps.join_path">join_path</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.load_pickle" href="#sedna.common.file_ops.FileOps.load_pickle">load_pickle</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.make_base_dir" href="#sedna.common.file_ops.FileOps.make_base_dir">make_base_dir</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.make_dir" href="#sedna.common.file_ops.FileOps.make_dir">make_dir</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.obj_to_pickle_string" href="#sedna.common.file_ops.FileOps.obj_to_pickle_string">obj_to_pickle_string</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.pickle_string_to_obj" href="#sedna.common.file_ops.FileOps.pickle_string_to_obj">pickle_string_to_obj</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.remove_path_prefix" href="#sedna.common.file_ops.FileOps.remove_path_prefix">remove_path_prefix</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.s3_download" href="#sedna.common.file_ops.FileOps.s3_download">s3_download</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.s3_upload" href="#sedna.common.file_ops.FileOps.s3_upload">s3_upload</a></code></li>
<li><code><a title="sedna.common.file_ops.FileOps.upload" href="#sedna.common.file_ops.FileOps.upload">upload</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc"><cite>pdoc</cite> 0.9.2</a>.</p>
</footer>
</body>
</html>